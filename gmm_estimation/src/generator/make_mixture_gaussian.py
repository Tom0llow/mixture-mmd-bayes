from typing import Optional

import numpy as np


def make_mixture_means(
    d: int,
    K: int,
    separation: float = 3.0,
    sigma: float = 1.0,
    layout_key: str = "auto",
) -> np.ndarray:
    """Construct K mean vectors in R^d with separation (in units of sigma).

    Strategy:
        - layout_key == "auto":
            - d == 1: equally spaced centers
            - d == 15: standard-basis placement with min distance = separation * sigma
            - d >= K: coordinate axes with alternating signs
            - d < K: circle in the first two dimensions
        - layout_key == "line": equally spaced centers in 1D
        - layout_key == "basis": standard-basis placement with min distance = separation * sigma
        - layout_key == "axes": coordinate axes with alternating signs
        - layout_key == "circle": circle in the first two dimensions

    Returns:
        means: (K, d)
    """
    delta = separation * sigma
    layout_key = layout_key.lower() if isinstance(layout_key, str) else "auto"
    if layout_key == "auto":
        if d == 1:
            layout_key = "line"
        elif d == 15:
            layout_key = "basis"
        elif d >= K:
            layout_key = "axes"
        else:
            layout_key = "circle"

    if layout_key == "line":
        centers = (np.arange(K) - (K - 1) / 2.0) * delta
        return centers.reshape(K, 1)

    if layout_key == "basis":
        if d < K:
            raise ValueError("basis layout requires d >= K.")
        means = np.zeros((K, d), dtype=float)
        amplitude = delta / np.sqrt(2.0)
        for k in range(K):
            means[k, k] = amplitude
        return means

    if layout_key == "axes":
        if d < K:
            raise ValueError("axes layout requires d >= K.")
        means = np.zeros((K, d), dtype=float)
        for k in range(K):
            means[k, k] = ((-1) ** k) * delta
        return means

    if layout_key == "circle":
        angles = np.linspace(0, 2 * np.pi, K, endpoint=False)
        means = np.zeros((K, d), dtype=float)
        radius = delta
        means[:, 0] = radius * np.cos(angles)
        if d >= 2:
            means[:, 1] = radius * np.sin(angles)
        return means

    raise ValueError(f"Unknown layout: {layout_key}")


def sample_mixture_gaussian(
    n: int,
    d: int,
    K: int,
    sigma: float = 1.0,
    separation: float = 3.0,
    weights: Optional[np.ndarray] = None,
    means: Optional[np.ndarray] = None,
    layout_key: str = "auto",
    rng: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """Sample n points from a Gaussian mixture with K components in R^d.

    Args:
        n: number of samples
        d: dimension
        K: number of components
        sigma: shared component std
        separation: mean separation scale
        weights: (K,) mixture weights; defaults to uniform
        means: (K, d) component means; if None, generated by make_mixture_means
        layout_key: layout name passed to make_mixture_means when means is None
        rng: numpy random generator

    Returns:
        X: (n, d)
    """
    rng = rng or np.random.default_rng()
    if means is None:
        means = make_mixture_means(d, K, separation=separation, sigma=sigma, layout_key=layout_key)
    else:
        means = np.asarray(means, dtype=float).reshape(K, d)

    if weights is None:
        weights = np.ones(K, dtype=float) / K
    weights = np.asarray(weights, dtype=float)
    if weights.size != K:
        raise ValueError(f"weights must have length K={K}, got {weights.size}.")
    weights = weights / weights.sum()

    z = rng.choice(K, size=n, p=weights)
    X = rng.normal(loc=means[z], scale=sigma, size=(n, d))
    return X
