from typing import Optional

import numpy as np


def make_mixture_means(
    d: int,
    K: int,
    separation: float = 3.0,
    sigma: float = 1.0,
) -> np.ndarray:
    """Construct K mean vectors in R^d with approximate separation (in units of sigma).

    Strategy:
        - d == 1: equally spaced centers
        - d >= K: place on coordinate axes with alternating signs
        - d < K: place on a circle in the first two dimensions

    Returns:
        means: (K, d)
    """
    if d == 1:
        centers = (np.arange(K) - (K - 1) / 2.0) * separation * sigma
        return centers.reshape(K, 1)

    if d >= K:
        means = np.zeros((K, d), dtype=float)
        for k in range(K):
            means[k, k] = ((-1) ** k) * separation * sigma
        return means

    angles = np.linspace(0, 2 * np.pi, K, endpoint=False)
    means = np.zeros((K, d), dtype=float)
    radius = separation * sigma
    means[:, 0] = radius * np.cos(angles)
    if d >= 2:
        means[:, 1] = radius * np.sin(angles)
    return means


def sample_mixture_gaussian(
    n: int,
    d: int,
    K: int,
    sigma: float = 1.0,
    separation: float = 3.0,
    weights: Optional[np.ndarray] = None,
    means: Optional[np.ndarray] = None,
    rng: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """Sample n points from a Gaussian mixture with K components in R^d.

    Args:
        n: number of samples
        d: dimension
        K: number of components
        sigma: shared component std
        separation: mean separation scale
        weights: (K,) mixture weights; defaults to uniform
        means: (K, d) component means; if None, generated by make_mixture_means
        rng: numpy random generator

    Returns:
        X: (n, d)
    """
    rng = rng or np.random.default_rng()
    if means is None:
        means = make_mixture_means(d, K, separation=separation, sigma=sigma)
    else:
        means = np.asarray(means, dtype=float).reshape(K, d)

    if weights is None:
        weights = np.ones(K, dtype=float) / K
    else:
        weights = np.asarray(weights, dtype=float)
        weights = weights / weights.sum()

    z = rng.choice(K, size=n, p=weights)
    X = rng.normal(loc=means[z], scale=sigma, size=(n, d))
    return X
